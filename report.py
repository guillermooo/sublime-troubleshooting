import contextlib
import abc

from .editor_info import EditorInfo
from .data import DataSection
from .data import DataItem


class MarkDownWriterMixin(object):

    def __init__(self):
        # We can't start adding stuff right away, we need to call .collect_markup() first.
        self.buf = None

    def write(self, text):
        self.buf.append(text)

    def write_line(self, text=''):
        self.buf.append(text + '\n')

    def h3(self, text):
        self.write_line('### ' + text)

    def quote(self, text):
        self.write_line('> ' + text)

    def italics(self, text):
        self.write('*{0}*'.format(text))

    @contextlib.contextmanager
    def collect_markup(self, buf):
        assert isinstance(buf, list)
        old_buf = self.buf
        self.buf = buf
        yield
        self.buf = old_buf


class Report(MarkDownWriterMixin):

    def __init__(self):
        super().__init__()
        self.infos = []
        self.infos.append(EditorInfo.from_current_editor())

    def generate(self):
        footer = '''---
This report was generated by the [Troubleshooting][self] package.

[self]: https://bitbucket.org/guillermooo/sublime-troubleshooting
'''
        buf = []
        for info in self.infos:
            with self.collect_markup(buf):
                self._collect_info_markup(info)                        
        buf.append('\n' + footer)
        return ''.join(buf)

    def _collect_info_markup(self, info):
        self.h3(info.title + ' (as provided by ' + info.provider + ')')
        if info.description:
            self.write_line()
            self.italics(info.description)
            self.write_line()
            self.write_line()

        for element in info.elements:
            if isinstance(element, DataItem):
                self.quote(element.name + ': ' + element.value)


def plugin_loaded():
    print(Report().generate())
